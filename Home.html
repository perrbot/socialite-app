<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Socialite - Elevate your vibe with luxury feeds, connected communities, and viral energy. ðŸ’Žâœ¨ #SocialiteGlowUp" />
  <title>Socialite - Home</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" onerror="this.href='';document.body.style.fontFamily='sans-serif';">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" onerror="this.href='';">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif; min-height: 100vh; background: linear-gradient(135deg, #4C51BF, #ED64A6, #9F7AEA); overflow: hidden;
      display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
    }
    .tiktok-feed {
      width: 100vw; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;
      position: relative;
    }
    .tiktok-post {
      width: 100vw; height: 80vh; max-width: 420px; background: rgba(255,255,255,0.12); border-radius: 30px; box-shadow: 0 8px 32px rgba(0,0,0,0.18);
      display: flex; flex-direction: row; align-items: center; justify-content: space-between; position: relative; margin: 0 auto;
      overflow: hidden;
    }
    .post-media { position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 0; overflow: hidden; }
    .post-media img, .post-media video { width: 100%; height: 100%; object-fit: cover; display: block; }
    .post-content, .post-actions { position: relative; z-index: 1; }
    .post-content {
      flex: 1; padding: 2vw 4vw; display: flex; flex-direction: column; justify-content: center; align-items: flex-start;
    }
    .post-user {
      font-weight: 700; font-size: 1.3em; color: #fff; margin-bottom: 1vh; text-shadow: 0 2px 8px #9F7AEA;
    }
    .post-text {
      font-size: 1.1em; color: #fff; margin-bottom: 2vh; text-shadow: 0 1px 6px #ED64A6;
    }
    .post-actions {
      width: 70px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 2vh;
      position: absolute; right: 2vw; top: 50%; transform: translateY(-50%);
    }
    .post-actions span {
      background: rgba(255,255,255,0.18); border-radius: 50%; padding: 12px; margin-bottom: 8px; color: #fff; font-size: 1.5em;
      box-shadow: 0 2px 8px #4C51BF; cursor: pointer; transition: background 0.2s, transform 0.2s;
      display: flex; align-items: center; justify-content: center;
    }
    .like-btn { display: inline-flex; align-items: center; gap: 6px; font-size: 1.1em; }
    .like-btn.liked i { color: #ff2d55; filter: drop-shadow(0 4px 8px rgba(255,45,85,0.25)); }
    .like-btn.pop { transform: scale(1.25); transition: transform 180ms cubic-bezier(.2,.9,.3,1); }
    .like-count { font-weight: 600; margin-left: 6px; }
    .post-actions span:hover { background: #ED64A6; transform: scale(1.15); }
    .bottom-nav {
      width: 100vw; max-width: 420px; height: 70px; background: rgba(255,255,255,0.18); border-radius: 30px 30px 0 0;
      position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; justify-content: space-around; align-items: center; z-index: 10;
      box-shadow: 0 -2px 12px rgba(0,0,0,0.12);
    }
    .bottom-nav span {
      color: #fff; font-size: 1.7em; cursor: pointer; transition: color 0.2s;
    }
    .bottom-nav span.active { color: #ED64A6; }
    .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFF; font-size: 2em; display: none; animation: blink 1s infinite; }
    @media (max-width: 480px) {
      .tiktok-post { height: 75vh; }
      .bottom-nav { height: 60px; }
    }
    @keyframes blink { 50% { opacity: 0.5; } }
    body.dark-mode { background: linear-gradient(135deg, #2D3748, #4A5568, #718096); }
    body.dark-mode .tiktok-post { background: rgba(45, 55, 72, 0.2); }
    body.dark-mode .post-user, body.dark-mode .post-text { color: #DDD; }
  </style>
</head>
<body>
  <div class="tiktok-feed">
    <div id="posts-container">
      <!-- Posts will be rendered here from Firestore. If Firestore is unavailable, a fallback message will be shown. -->
    </div>
    <div class="loading" id="loading">Loading...</div>
  </div>
  <div class="bottom-nav">
    <a class="nav-item active" href="Home.html" aria-label="Home"><i class="fas fa-home"></i></a>
    <a class="nav-item" href="Index_new.html" aria-label="Discover"><i class="fas fa-search"></i></a>
    <a class="nav-item" href="post-enhanced.html" aria-label="Create"><i class="fas fa-plus-circle"></i></a>
    <a class="nav-item" href="Notification.html" aria-label="Inbox"><i class="fas fa-inbox"></i></a>
    <a class="nav-item" href="friend.html" aria-label="Friends"><i class="fas fa-users"></i></a>
  </div>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js" async></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js" async></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-analytics-compat.js" async></script>
  <script src="common.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDdfcTtRD-HdvB_n_colrUWQI-FUZAiNh0",
      authDomain: "socialite-bae96.firebaseapp.com",
      projectId: "socialite-bae96",
      storageBucket: "socialite-bae96.firebasestorage.app",
      messagingSenderId: "871563265567",
      appId: "1:871563265567:web:60b88ac1688f8af3ae372a",
      measurementId: "G-5LN8406TPX"
    };

    let app, auth, analytics;
    document.getElementById('loading').style.display = 'block';
    // Initialize firebase; allow retry if scripts load slowly
    setTimeout(async () => {
      try {
        if (!window.firebaseApp) {
          app = firebase.initializeApp(firebaseConfig);
          auth = firebase.auth();
          analytics = firebase.analytics(app);
          window.firebaseApp = app;
        } else {
          app = window.firebaseApp;
          auth = firebase.auth();
          analytics = firebase.analytics(app);
        }
        document.getElementById('loading').style.display = 'none';

        auth.onAuthStateChanged((user) => {
          if (!user) return window.location.replace('login.html');
          // Once logged in, load initial posts and start SSE
          loadInitialPosts();
          startPostSSE();
        });
      } catch (e) {
        console.error("Firebase initialization failed:", e);
        document.getElementById('loading').textContent = 'Retry in progress...';
        setTimeout(() => location.reload(), 2000);
      }
    }, 1000);


    // Dynamic posts, like toggle, keyboard + touch swipe navigation
    let currentIndex = 0;
    let posts = []; // array of post elements

    function showPost(index) {
      if (!posts.length) return;
      posts.forEach((el, i) => el.style.display = i === index ? 'flex' : 'none');
      currentIndex = index;
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        const next = e.key === 'ArrowDown' ? (currentIndex + 1) % posts.length : (currentIndex - 1 + posts.length) % posts.length;
        showPost(next);
      }
    });

    // Touch swipe support
    let touchStartY = 0;
    let touchEndY = 0;
    const threshold = 50;
    document.addEventListener('touchstart', (e) => { touchStartY = e.changedTouches[0].screenY; });
    document.addEventListener('touchend', (e) => {
      touchEndY = e.changedTouches[0].screenY;
      const diff = touchStartY - touchEndY;
      if (Math.abs(diff) > threshold && posts.length) {
        if (diff > 0) { // swipe up -> next
          showPost((currentIndex + 1) % posts.length);
        } else { // swipe down -> prev
          showPost((currentIndex - 1 + posts.length) % posts.length);
        }
      }
    });

    // Post renderer (expects plain post object from backend)
    function renderPost(post, idx) {
      const data = post || {};
      const id = data._id || data.id || idx;
      const postEl = document.createElement('div');
      postEl.className = 'tiktok-post';
      postEl.id = 'post-' + id;
      postEl.style.display = 'none';

      if (id) postEl.setAttribute('data-doc-id', id);

      // media container (image or video)
      let videoEl = null;
      const hasVideo = data.mediaUrl && (data.mediaType === 'video' || (data.videoUrl));
      const hasImage = data.mediaUrl && (data.mediaType === 'image' || (data.imageUrl && !hasVideo));
      if (hasVideo || hasImage) {
        const mediaWrap = document.createElement('div'); mediaWrap.className = 'post-media';
        if (hasVideo) {
          videoEl = document.createElement('video');
          videoEl.src = data.videoUrl || data.mediaUrl;
          videoEl.setAttribute('playsinline', '');
          videoEl.setAttribute('muted', '');
          videoEl.setAttribute('preload', 'metadata');
          videoEl.loop = true;
          mediaWrap.appendChild(videoEl);
        } else {
          const img = document.createElement('img'); img.src = data.imageUrl || data.mediaUrl; mediaWrap.appendChild(img);
        }
        postEl.appendChild(mediaWrap);
      }

      const content = document.createElement('div');
      content.className = 'post-content';
      const username = data.user && data.user.username ? data.user.username : (data.user || data.username || 'Unknown');
      const user = document.createElement('div'); user.className = 'post-user'; user.textContent = username;
      const text = document.createElement('div'); text.className = 'post-text'; text.textContent = data.content || data.text || '';
      content.appendChild(user); content.appendChild(text);

      const actions = document.createElement('div'); actions.className = 'post-actions';

      // Like button (optimistic toggle)
      const likeBtn = document.createElement('button');
      likeBtn.className = 'like-btn';
      likeBtn.setAttribute('aria-label', 'Like post');
      likeBtn.innerHTML = `<i class="fas fa-heart"></i><span class="like-count"> ${data.likes || 0}</span>`;
      likeBtn.dataset.liked = (data.likedBy && Array.isArray(data.likedBy) && auth.currentUser && data.likedBy.includes(auth.currentUser.uid)) ? 'true' : 'false';
      if (likeBtn.dataset.liked === 'true') likeBtn.classList.add('liked');
      likeBtn.style.border = 'none'; likeBtn.style.background = 'transparent'; likeBtn.style.color = 'white';
      likeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const userObj = auth.currentUser;
        if (!userObj) return window.location.replace('login.html');
        const uid = userObj.uid;
        const countSpan = likeBtn.querySelector('.like-count');
        const prevLiked = likeBtn.dataset.liked === 'true';
        // optimistic UI update
        let currentCount = parseInt((countSpan.textContent || '').trim()) || 0;
        if (prevLiked) {
          currentCount = Math.max(0, currentCount - 1);
          likeBtn.dataset.liked = 'false';
          likeBtn.classList.remove('liked');
        } else {
          currentCount = currentCount + 1;
          likeBtn.dataset.liked = 'true';
          likeBtn.classList.add('liked');
          likeBtn.classList.add('pop');
          setTimeout(() => likeBtn.classList.remove('pop'), 220);
        }
        countSpan.textContent = ` ${currentCount}`;

        // reconcile with server via backend API
        try {
          const token = await auth.currentUser.getIdToken();
          const res = await fetch(`/api/posts/${encodeURIComponent(id)}/like`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
            body: JSON.stringify({})
          });
          if (!res.ok) throw new Error('Server error');
          const json = await res.json();
          // sync UI with server value
          if (json && typeof json.likes !== 'undefined') {
            countSpan.textContent = ` ${json.likes}`;
            likeBtn.dataset.liked = json.liked ? 'true' : 'false';
            if (json.liked) likeBtn.classList.add('liked'); else likeBtn.classList.remove('liked');
          }
          try { analytics.logEvent('post_like'); } catch (err) {}
        } catch (err) {
          // revert optimistic UI on error
          console.error('Like failed', err);
          if (prevLiked) {
            likeBtn.dataset.liked = 'true';
            likeBtn.classList.add('liked');
            countSpan.textContent = ` ${currentCount + 1}`;
          } else {
            likeBtn.dataset.liked = 'false';
            likeBtn.classList.remove('liked');
            countSpan.textContent = ` ${Math.max(0, currentCount - 1)}`;
          }
        }
      });

      // Comment link (navigates to Chat with query param)
      const commentA = document.createElement('a');
      commentA.href = 'Chat.html?post=' + encodeURIComponent(id);
      commentA.innerHTML = '<span><i class="fas fa-comment-dots"></i></span>';

      // Share link with Web Share fallback
      const shareA = document.createElement('a');
      shareA.href = 'Index_new.html';
      shareA.id = 'share-' + id;
      shareA.innerHTML = '<span><i class="fas fa-share"></i></span>';
      shareA.addEventListener('click', async (e) => {
        if (navigator.share) {
          e.preventDefault();
          try { await navigator.share({ title: username || document.title, url: window.location.href + '#post-' + id }); }
          catch (err) { window.location.href = shareA.getAttribute('href'); }
        }
      });

      actions.appendChild(likeBtn);
      actions.appendChild(commentA);
      actions.appendChild(shareA);

      postEl.appendChild(content);
      postEl.appendChild(actions);

      // If there's a video element, observe visibility for autoplay/pause
      if (videoEl) {
        window.postObserver = window.postObserver || new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const video = entry.target.querySelector('video');
            if (!video) return;
            if (entry.intersectionRatio > 0.6) {
              video.muted = true;
              video.play().catch(() => {});
            } else {
              video.pause();
            }
          });
        }, { threshold: [0.6] });
        try { window.postObserver.observe(postEl); } catch (e) { console.error(e); }
      }

      return postEl;
    }

    let eventSource = null;
    function clearContainer() {
      const container = document.getElementById('posts-container');
      container.innerHTML = '';
      posts = [];
    }

    async function loadInitialPosts() {
      const container = document.getElementById('posts-container');
      container.innerHTML = '';
      document.getElementById('loading').style.display = 'block';
      try {
        const res = await fetch('/api/posts');
        if (!res.ok) throw new Error('Failed to fetch posts');
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          const fallback = [{ user: 'Jane Doe', content: 'Had a great day at the beach! ðŸŒŠâ˜€ï¸', likes: 0 }, { user: 'John Smith', content: 'Just finished building my dream app with Firebase!', likes: 0 }];
          fallback.forEach((p, i) => container.appendChild(renderPost(p, i)));
        } else {
          data.forEach((p, i) => container.appendChild(renderPost(p, i)));
        }
        posts = Array.from(container.children);
        if (posts.length) showPost(0);
      } catch (err) {
        console.error('Failed to load initial posts', err);
        // Show fallback posts instead of error message
        const fallback = [{ user: 'Jane Doe', content: 'Had a great day at the beach! ðŸŒŠâ˜€ï¸', likes: 0 }, { user: 'John Smith', content: 'Just finished building my dream app with Firebase!', likes: 0 }];
        fallback.forEach((p, i) => container.appendChild(renderPost(p, i)));
        posts = Array.from(container.children);
        if (posts.length) showPost(0);
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    function startPostSSE() {
      if (eventSource) return;

      // Attempt to create a short-lived SSE session cookie, then open EventSource without tokens in URL.
      let backoff = 1000; // ms
      const maxBackoff = 30000;

      const connect = async () => {
        try {
          // create server-side SSE session cookie
          try {
            const token = await auth.currentUser.getIdToken();
            await fetch('/api/posts/sse/session', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({})
            });
            // now open EventSource without token in URL; cookie will be sent automatically for same-origin
            eventSource = new EventSource('/api/posts/stream');
          } catch (e) {
            // if session creation fails, fallback to token-in-url approach
            const token = await auth.currentUser.getIdToken();
            const url = `/api/posts/stream?token=${encodeURIComponent(token)}`;
            eventSource = new EventSource(url);
          }

          eventSource.addEventListener('newPost', (e) => {
            try {
              const post = JSON.parse(e.data);
              const container = document.getElementById('posts-container');
              container.insertBefore(renderPost(post, 0), container.firstChild);
              posts = Array.from(container.children);
              showPost(0);
            } catch (err) { console.error('Failed to parse newPost', err); }
          });

          eventSource.addEventListener('updatePost', (e) => {
            try {
              const post = JSON.parse(e.data);
              const el = document.querySelector(`#post-${post._id}`);
              if (el) {
                const newEl = renderPost(post);
                el.replaceWith(newEl);
                posts = Array.from(document.getElementById('posts-container').children);
              }
            } catch (err) { console.error('Failed to parse updatePost', err); }
          });

          eventSource.addEventListener('deletePost', (e) => {
            try {
              const payload = JSON.parse(e.data);
              const el = document.querySelector(`#post-${payload._id}`);
              if (el) el.remove();
              posts = Array.from(document.getElementById('posts-container').children);
              if (currentIndex >= posts.length) showPost(Math.max(0, posts.length - 1));
            } catch (err) { console.error('Failed to parse deletePost', err); }
          });

          eventSource.addEventListener('refresh', (e) => {
            try {
              const data = JSON.parse(e.data);
              clearContainer();
              const container = document.getElementById('posts-container');
              data.forEach((p, i) => container.appendChild(renderPost(p, i)));
              posts = Array.from(container.children);
              if (posts.length) showPost(0);
            } catch (err) { console.error('Failed to handle refresh', err); }
          });

          eventSource.addEventListener('refreshDiff', (e) => {
            try {
              const changed = JSON.parse(e.data);
              const container = document.getElementById('posts-container');
              changed.forEach(p => {
                const existing = document.querySelector(`#post-${p._id}`);
                if (existing) {
                  existing.replaceWith(renderPost(p));
                } else {
                  container.insertBefore(renderPost(p, 0), container.firstChild);
                }
              });
              posts = Array.from(container.children);
            } catch (err) { console.error('Failed to handle refreshDiff', err); }
          });

          eventSource.onerror = async (err) => {
            console.error('SSE error', err);
            try { eventSource.close(); } catch (e) {}
            eventSource = null;
            // attempt reconnect with backoff
            const wait = backoff + Math.floor(Math.random() * 300);
            backoff = Math.min(maxBackoff, backoff * 2);
            setTimeout(connect, wait);
          };

          // Reset backoff on successful open
          eventSource.onopen = () => { backoff = 1000; };
        } catch (err) {
          console.error('Failed to open SSE (overall)', err);
          try { await auth.currentUser.getIdToken(true); } catch (e) {}
          const wait = backoff + Math.floor(Math.random() * 300);
          backoff = Math.min(maxBackoff, backoff * 2);
          setTimeout(connect, wait);
        }
      };

      connect();
    }

    // Cleanup listener when navigating away
    window.addEventListener('beforeunload', () => {
      if (_unsubscribePosts) _unsubscribePosts();
      if (window.postUnsubscribers) {
        Object.values(window.postUnsubscribers).forEach(fn => { try { fn(); } catch (e) {} });
      }
      if (window.postObserver) {
        try { window.postObserver.disconnect(); } catch (e) {}
      }
    });


    if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark-mode');
  </script>
</body>
</html>