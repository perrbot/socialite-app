<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Socialite - Elevate your vibe with luxury feeds, connected communities, and viral energy. ðŸ’Žâœ¨ #SocialiteGlowUp" />
  <title>Socialite - Home</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" onerror="this.href='';document.body.style.fontFamily='sans-serif';">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" onerror="this.href='';">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif; min-height: 100vh; background: linear-gradient(135deg, #4C51BF, #ED64A6, #9F7AEA); overflow: hidden;
      display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
    }
    /* Fullscreen vertical feed like TikTok */
    .tiktok-feed {
      width: 100vw; height: 100vh; display: block; position: relative; overflow: hidden;
      background: linear-gradient(135deg, #4C51BF, #ED64A6, #9F7AEA);
    }
    .tiktok-post {
      width: 100vw; height: 100vh; max-width: 100vw; background: transparent; display: block; position: relative; margin: 0 auto; overflow: hidden;
      display: flex; align-items: stretch; justify-content: center;
    }
    .post-media { position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 0; overflow: hidden; }
    .post-media img, .post-media video { width: 100%; height: 100%; object-fit: cover; display: block; }

    /* Overlay UI */
    .post-overlay { position: absolute; left: 0; right: 0; bottom: 0; z-index: 2; padding: 16px; display:flex; justify-content:space-between; gap:12px; align-items:flex-end; }
    .post-left { color: #fff; max-width: 72%; }
    .post-username { font-weight: 700; font-size: 1rem; margin-bottom:6px; }
    .post-caption { font-size: 0.95rem; opacity: 0.95; margin-bottom:8px; }
    .post-music { display:flex; gap:8px; align-items:center; opacity:0.9; font-size:0.85rem; }

    .post-right { width:74px; display:flex; flex-direction:column; align-items:center; gap:14px; margin-bottom:40px; z-index:3 }
    .action-btn { width:56px; height:56px; border-radius:50%; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; color:#fff; border:none; cursor:pointer; }
    .action-count { font-size:0.85rem; color:#fff; margin-top:6px; text-align:center; }

    .profile-avatar { width:48px; height:48px; border-radius:50%; border:2px solid #fff; overflow:hidden; margin-bottom:6px; }

    /* Top progress bar */
    .progress-top { position:absolute; left:0; right:0; top:0; height:3px; z-index:4; display:flex; gap:2px; padding:6px; }
    .progress-seg { flex:1; background:rgba(255,255,255,0.25); height:3px; border-radius:2px; overflow:hidden; }
    .progress-fill { height:100%; background:linear-gradient(90deg,#ED64A6,#4C51BF); width:0%; }
    .like-btn { display: inline-flex; align-items: center; gap: 6px; font-size: 1.1em; }
    .like-btn.liked i { color: #ff2d55; filter: drop-shadow(0 4px 8px rgba(255,45,85,0.25)); }
    .like-btn.pop { transform: scale(1.25); transition: transform 180ms cubic-bezier(.2,.9,.3,1); }
    .like-count { font-weight: 600; margin-left: 6px; }
    .post-actions span:hover { background: #ED64A6; transform: scale(1.15); }
    .bottom-nav {
      width: 100vw; max-width: 420px; height: 70px; background: rgba(255,255,255,0.18); border-radius: 30px 30px 0 0;
      position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; justify-content: space-around; align-items: center; z-index: 10;
      box-shadow: 0 -2px 12px rgba(0,0,0,0.12);
    }
    .bottom-nav span {
      color: #fff; font-size: 1.7em; cursor: pointer; transition: color 0.2s;
    }
    .bottom-nav span.active { color: #ED64A6; }
    .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFF; font-size: 2em; display: none; animation: blink 1s infinite; }
    @media (max-width: 480px) {
      .tiktok-post { height: 75vh; }
      .bottom-nav { height: 60px; }
    }
    @keyframes blink { 50% { opacity: 0.5; } }
    body.dark-mode { background: linear-gradient(135deg, #2D3748, #4A5568, #718096); }
    body.dark-mode .tiktok-post { background: rgba(45, 55, 72, 0.2); }
    body.dark-mode .post-user, body.dark-mode .post-text { color: #DDD; }
    #live-notify { position: fixed; right: 14px; top: 14px; z-index: 9999; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
    #nav-inbox { position: relative; }
    #inbox-badge { position: absolute; top: -6px; right: -10px; background: #ff2d55; color: #fff; border-radius: 12px; padding: 2px 6px; font-size: 12px; display: none; }
  </style>
</head>
<body>
  <div class="tiktok-feed">
    <div id="posts-container">
      <!-- Posts will be rendered here from Firestore. If Firestore is unavailable, a fallback message will be shown. -->
    </div>
    <div class="loading" id="loading">Loading...</div>
    <!-- small floating notifications for live activity -->
    <div id="live-notify">
      <!-- notifications injected here -->
    </div>
  </div>
  <div class="bottom-nav">
    <a class="nav-item active" href="Home.html" aria-label="Home"><i class="fas fa-home"></i></a>
    <a class="nav-item" href="Index_new.html" aria-label="Discover"><i class="fas fa-search"></i></a>
    <a class="nav-item" href="post-enhanced.html" aria-label="Create"><i class="fas fa-plus-circle"></i></a>
    <a id="nav-inbox" class="nav-item" href="Notification.html" aria-label="Inbox">
      <i class="fas fa-inbox"></i>
      <span id="inbox-badge">0</span>
    </a>
    <a class="nav-item" href="friend.html" aria-label="Friends"><i class="fas fa-users"></i></a>
  </div>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js" async></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js" async></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js" async></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-analytics-compat.js" async></script>
  <script src="common.js"></script>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDdfcTtRD-HdvB_n_colrUWQI-FUZAiNh0",
      authDomain: "socialite-bae96.firebaseapp.com",
      projectId: "socialite-bae96",
      storageBucket: "socialite-bae96.firebasestorage.app",
      messagingSenderId: "871563265567",
      appId: "1:871563265567:web:60b88ac1688f8af3ae372a",
      measurementId: "G-5LN8406TPX"
    };

    let app, auth, analytics;
    document.getElementById('loading').style.display = 'block';
    // Initialize firebase; allow retry if scripts load slowly
    setTimeout(async () => {
      try {
        if (!window.firebaseApp) {
          app = firebase.initializeApp(firebaseConfig);
          auth = firebase.auth();
          // initialize firestore for user search and follow actions
          try { window.db = firebase.firestore(); } catch (e) { console.warn('Firestore init failed', e); }
          analytics = firebase.analytics(app);
          window.firebaseApp = app;
        } else {
          app = window.firebaseApp;
          auth = firebase.auth();
          try { window.db = firebase.firestore(); } catch (e) { /* ignore */ }
          analytics = firebase.analytics(app);
        }
        document.getElementById('loading').style.display = 'none';

        auth.onAuthStateChanged((user) => {
          if (!user) return window.location.replace('login.html');
          // Once logged in, load initial posts and start SSE
            loadInitialPosts();
            startPostSSE();
            // initialize search UI once signed in
            initSearchUI();

            // connect socket.io for real-time likes/comments
            try {
              window.socket = io(location.origin);
              window.socket.on('connect', () => {
                console.log('socket connected', window.socket.id);
                // join user room so server can push notifications
                if (auth.currentUser) window.socket.emit('join', `user:${auth.currentUser.uid}`);
              });

              window.socket.on('like', (payload) => {
                try {
                  const el = document.querySelector(`#post-${payload.postId}`);
                  if (el) {
                    const cnt = el.querySelector('.action-count');
                    if (cnt) cnt.textContent = (payload.likes || cnt.textContent || 0);
                    const btn = el.querySelector('.action-btn');
                    if (btn && payload.byUserId && auth.currentUser && payload.byUserId === auth.currentUser.uid) btn.classList.add('liked');
                    // animate like button for visual feedback
                    try {
                      if (btn) {
                        btn.classList.add('pop');
                        setTimeout(() => btn.classList.remove('pop'), 300);
                      }
                    } catch(_){}
                    // show a small toast notification
                    try { showLiveNotification((payload.byUserName || 'Someone') + ' liked your post'); } catch(_){}
                  }
                } catch (e) { console.warn('like handler', e); }
              });

              window.socket.on('comment', (payload) => {
                try {
                  const el = document.querySelector(`#post-${payload.postId}`);
                  if (el) {
                    const commentCnt = el.querySelectorAll('.action-count')[1]; // second count is comments
                    if (commentCnt) commentCnt.textContent = (payload.comments || commentCnt.textContent || 0);
                    // show notification for comment
                    try { showLiveNotification((payload.byUserName || 'Someone') + ' commented: ' + (payload.preview || '...')); } catch(_){}
                  }
                } catch (e) { console.warn('comment handler', e); }
              });
            } catch (e) { console.warn('socket init failed', e); }
        });
      } catch (e) {
        console.error("Firebase initialization failed:", e);
        document.getElementById('loading').textContent = 'Retry in progress...';
        setTimeout(() => location.reload(), 2000);
      }
    }, 1000);


    // Dynamic posts, like toggle, keyboard + touch swipe navigation
    let currentIndex = 0;
    let posts = []; // array of post elements

    function showPost(index) {
      if (!posts.length) return;
      posts.forEach((el, i) => el.style.display = i === index ? 'flex' : 'none');
      currentIndex = index;
    }

    // Live notification helper
    function showLiveNotification(text) {
      try {
        const wrap = document.getElementById('live-notify');
        if (!wrap) return;
        const note = document.createElement('div');
        note.style.pointerEvents = 'auto';
        note.style.background = 'linear-gradient(45deg,#111827,#1f2937)';
        note.style.color = '#fff';
        note.style.padding = '8px 12px';
        note.style.borderRadius = '10px';
        note.style.boxShadow = '0 6px 18px rgba(0,0,0,0.35)';
        note.style.fontSize = '13px';
        note.style.opacity = '0';
        note.style.transform = 'translateY(-6px)';
        note.textContent = text;
        wrap.appendChild(note);
        // animate
        requestAnimationFrame(() => { note.style.transition = 'all 260ms ease'; note.style.opacity = '1'; note.style.transform = 'translateY(0)'; });
        setTimeout(() => {
          note.style.opacity = '0'; note.style.transform = 'translateY(-6px)';
          setTimeout(() => { try { wrap.removeChild(note); } catch(_){} }, 300);
        }, 3000);
      } catch (e) { console.warn('notify failed', e); }
    }

    // Unread live-events badge (persist per-session)
    let unreadCount = Number(sessionStorage.getItem('liveUnread') || 0);
    const inboxBadge = document.getElementById('inbox-badge');
    function updateInboxBadge() {
      if (!inboxBadge) return;
      if (unreadCount > 0) {
        inboxBadge.style.display = 'inline-block';
        inboxBadge.textContent = String(unreadCount > 99 ? '99+' : unreadCount);
      } else {
        inboxBadge.style.display = 'none';
      }
      sessionStorage.setItem('liveUnread', String(unreadCount));
    }
    function incrementUnread() { unreadCount = Math.min(999, unreadCount + 1); updateInboxBadge(); }
    function clearUnread() { unreadCount = 0; updateInboxBadge(); }
    updateInboxBadge();

    // Clear unread when navigating to notifications
    const navInbox = document.getElementById('nav-inbox');
    if (navInbox) {
      navInbox.addEventListener('click', () => { clearUnread(); });
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
        const next = e.key === 'ArrowDown' ? (currentIndex + 1) % posts.length : (currentIndex - 1 + posts.length) % posts.length;
        showPost(next);
      }
    });

    // Touch swipe support
    let touchStartY = 0;
    let touchEndY = 0;
    const threshold = 50;
    document.addEventListener('touchstart', (e) => { touchStartY = e.changedTouches[0].screenY; });
    document.addEventListener('touchend', (e) => {
      touchEndY = e.changedTouches[0].screenY;
      const diff = touchStartY - touchEndY;
      if (Math.abs(diff) > threshold && posts.length) {
        if (diff > 0) { // swipe up -> next
          showPost((currentIndex + 1) % posts.length);
        } else { // swipe down -> prev
          showPost((currentIndex - 1 + posts.length) % posts.length);
        }
      }
    });

    // Post renderer (expects plain post object from backend)
    function renderPost(post, idx) {
      const data = post || {};
      const id = data._id || data.id || idx;
      const postEl = document.createElement('div');
      postEl.className = 'tiktok-post';
      postEl.id = 'post-' + id;
      postEl.style.display = 'none';
      if (id) postEl.setAttribute('data-doc-id', id);

      // media container
      let videoEl = null;
      const hasVideo = data.mediaUrl && (data.mediaType === 'video' || (data.videoUrl));
      const hasImage = data.mediaUrl && (data.mediaType === 'image' || (data.imageUrl && !hasVideo));
      const mediaWrap = document.createElement('div'); mediaWrap.className = 'post-media';
      if (hasVideo) {
        videoEl = document.createElement('video');
        videoEl.src = data.videoUrl || data.mediaUrl;
        videoEl.setAttribute('playsinline', '');
        videoEl.setAttribute('muted', '');
        videoEl.setAttribute('preload', 'metadata');
        videoEl.loop = true;
        videoEl.style.width = '100%'; videoEl.style.height = '100%';
        mediaWrap.appendChild(videoEl);
      } else if (hasImage) {
        const img = document.createElement('img'); img.src = data.imageUrl || data.mediaUrl; img.style.width='100%'; img.style.height='100%'; mediaWrap.appendChild(img);
      }
      postEl.appendChild(mediaWrap);

      // overlay UI
      const overlay = document.createElement('div'); overlay.className = 'post-overlay';
      const left = document.createElement('div'); left.className = 'post-left';
      const right = document.createElement('div'); right.className = 'post-right';

      const username = data.user && data.user.username ? data.user.username : (data.user || data.username || 'Unknown');
      const displayName = document.createElement('div'); displayName.className = 'post-username'; displayName.textContent = '@' + username;
      const caption = document.createElement('div'); caption.className = 'post-caption'; caption.textContent = data.content || data.text || '';
      const music = document.createElement('div'); music.className = 'post-music'; music.innerHTML = '<i class="fas fa-music"></i> ' + (data.music || 'Original sound - ' + username);
      left.appendChild(displayName); left.appendChild(caption); left.appendChild(music);

      // right actions: avatar, like, comment, share
      const avatarWrap = document.createElement('div'); avatarWrap.className = 'profile-avatar';
      const avatarImg = document.createElement('img'); avatarImg.src = (data.user && data.user.photoURL) || ('https://ui-avatars.com/api/?name=' + encodeURIComponent(username) + '&background=ED64A6&color=fff&size=48'); avatarImg.style.width='100%'; avatarImg.style.height='100%'; avatarWrap.appendChild(avatarImg);
      right.appendChild(avatarWrap);

      // like
      const likeBtn = document.createElement('button'); likeBtn.className = 'action-btn'; likeBtn.innerHTML = '<i class="fas fa-heart"></i>';
      const likeCount = document.createElement('div'); likeCount.className = 'action-count'; likeCount.textContent = (data.likes || 0);
      // comment
      const commentBtn = document.createElement('button'); commentBtn.className = 'action-btn'; commentBtn.innerHTML = '<i class="fas fa-comment-dots"></i>';
      const commentCount = document.createElement('div'); commentCount.className = 'action-count'; commentCount.textContent = (data.comments || 0);
      // share
      const shareBtn = document.createElement('button'); shareBtn.className = 'action-btn'; shareBtn.innerHTML = '<i class="fas fa-share"></i>';
      const shareCount = document.createElement('div'); shareCount.className = 'action-count'; shareCount.textContent = (data.shares || 0);

      // wire like action (preserve optimistic update)
      likeBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        const userObj = auth.currentUser;
        if (!userObj) return window.location.replace('login.html');
        const prev = likeBtn.dataset.liked === 'true';
        let cur = Number(likeCount.textContent || 0);
        if (prev) { cur = Math.max(0, cur - 1); likeBtn.dataset.liked = 'false'; likeBtn.style.color = '#fff'; }
        else { cur = cur + 1; likeBtn.dataset.liked = 'true'; likeBtn.style.color = '#ff2d55'; }
        likeCount.textContent = cur;
        try {
          const token = await auth.currentUser.getIdToken();
          const res = await fetch(`/api/posts/${encodeURIComponent(id)}/like`, { method: 'POST', headers: { 'Content-Type':'application/json', 'Authorization':'Bearer ' + token }, body: JSON.stringify({}) });
          if (!res.ok) throw new Error('Server');
          const json = await res.json();
          likeCount.textContent = json.likes || cur;
        } catch (err) { console.error('Like failed', err); }
      });

      commentBtn.addEventListener('click', () => { window.location.href = 'Chat.html?post=' + encodeURIComponent(id); });
      shareBtn.addEventListener('click', async (e) => { if (navigator.share) { e.preventDefault(); try { await navigator.share({ title: caption.textContent || 'Socialite', url: window.location.href + '#post-' + id }); } catch (err) { console.warn(err); } } else { window.location.href = 'Index_new.html'; } });

      right.appendChild(likeBtn); right.appendChild(likeCount);
      right.appendChild(commentBtn); right.appendChild(commentCount);
      right.appendChild(shareBtn); right.appendChild(shareCount);

      overlay.appendChild(left); overlay.appendChild(right);
      postEl.appendChild(overlay);

      // progress top (single segment per video)
      const progress = document.createElement('div'); progress.className = 'progress-top'; const seg = document.createElement('div'); seg.className = 'progress-seg'; const fill = document.createElement('div'); fill.className = 'progress-fill'; seg.appendChild(fill); progress.appendChild(seg); postEl.appendChild(progress);

      // autoplay logic using IntersectionObserver
      if (videoEl) {
        window.postObserver = window.postObserver || new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const el = entry.target;
            const video = el.querySelector('video');
            const fill = el.querySelector('.progress-fill');
            if (!video) return;
            if (entry.intersectionRatio > 0.6) {
              video.muted = true;
              video.play().catch(()=>{});
              // animate progress
              try { fill.style.width = '0%'; setTimeout(()=>{ fill.style.transition='width '+(video.duration||5)+'s linear'; fill.style.width='100%'; },50); } catch(e){}
              // join the socket room for this post so server can forward live events
              try { if (window.socket) window.socket.emit('join', `post:${id}`); } catch(_) {}
            } else {
              video.pause();
              try { fill.style.transition='none'; fill.style.width='0%'; } catch(e){}
            }
          });
        }, { threshold: [0.6] });
        try { window.postObserver.observe(postEl); } catch (e) { console.error(e); }
      }

      return postEl;
    }

    let eventSource = null;
    function clearContainer() {
      const container = document.getElementById('posts-container');
      container.innerHTML = '';
      posts = [];
    }

    async function loadInitialPosts() {
      const container = document.getElementById('posts-container');
      container.innerHTML = '';
      document.getElementById('loading').style.display = 'block';
      try {
        const res = await fetch('/api/posts');
        if (!res.ok) throw new Error('Failed to fetch posts');
        const data = await res.json();
        if (!Array.isArray(data) || data.length === 0) {
          const fallback = [{ user: 'Jane Doe', content: 'Had a great day at the beach! ðŸŒŠâ˜€ï¸', likes: 0 }, { user: 'John Smith', content: 'Just finished building my dream app with Firebase!', likes: 0 }];
          fallback.forEach((p, i) => container.appendChild(renderPost(p, i)));
        } else {
          data.forEach((p, i) => container.appendChild(renderPost(p, i)));
        }
        posts = Array.from(container.children);
        if (posts.length) showPost(0);
      } catch (err) {
        console.error('Failed to load initial posts', err);
        // Show fallback posts instead of error message
        const fallback = [{ user: 'Jane Doe', content: 'Had a great day at the beach! ðŸŒŠâ˜€ï¸', likes: 0 }, { user: 'John Smith', content: 'Just finished building my dream app with Firebase!', likes: 0 }];
        fallback.forEach((p, i) => container.appendChild(renderPost(p, i)));
        posts = Array.from(container.children);
        if (posts.length) showPost(0);
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    function startPostSSE() {
      if (eventSource) return;

      // Attempt to create a short-lived SSE session cookie, then open EventSource without tokens in URL.
      let backoff = 1000; // ms
      const maxBackoff = 30000;

      const connect = async () => {
        try {
          // create server-side SSE session cookie
          try {
            const token = await auth.currentUser.getIdToken();
            await fetch('/api/posts/sse/session', {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify({})
            });
            // now open EventSource without token in URL; cookie will be sent automatically for same-origin
            eventSource = new EventSource('/api/posts/stream');
          } catch (e) {
            // if session creation fails, fallback to token-in-url approach
            const token = await auth.currentUser.getIdToken();
            const url = `/api/posts/stream?token=${encodeURIComponent(token)}`;
            eventSource = new EventSource(url);
          }

          eventSource.addEventListener('newPost', (e) => {
            try {
              const post = JSON.parse(e.data);
              const container = document.getElementById('posts-container');
              container.insertBefore(renderPost(post, 0), container.firstChild);
              posts = Array.from(container.children);
              showPost(0);
            } catch (err) { console.error('Failed to parse newPost', err); }
          });

          eventSource.addEventListener('updatePost', (e) => {
            try {
              const post = JSON.parse(e.data);
              const el = document.querySelector(`#post-${post._id}`);
              if (el) {
                const newEl = renderPost(post);
                el.replaceWith(newEl);
                posts = Array.from(document.getElementById('posts-container').children);
              }
            } catch (err) { console.error('Failed to parse updatePost', err); }
          });

          eventSource.addEventListener('deletePost', (e) => {
            try {
              const payload = JSON.parse(e.data);
              const el = document.querySelector(`#post-${payload._id}`);
              if (el) el.remove();
              posts = Array.from(document.getElementById('posts-container').children);
              if (currentIndex >= posts.length) showPost(Math.max(0, posts.length - 1));
            } catch (err) { console.error('Failed to parse deletePost', err); }
          });

          eventSource.addEventListener('refresh', (e) => {
            try {
              const data = JSON.parse(e.data);
              clearContainer();
              const container = document.getElementById('posts-container');
              data.forEach((p, i) => container.appendChild(renderPost(p, i)));
              posts = Array.from(container.children);
              if (posts.length) showPost(0);
            } catch (err) { console.error('Failed to handle refresh', err); }
          });

          eventSource.addEventListener('refreshDiff', (e) => {
            try {
              const changed = JSON.parse(e.data);
              const container = document.getElementById('posts-container');
              changed.forEach(p => {
                const existing = document.querySelector(`#post-${p._id}`);
                if (existing) {
                  existing.replaceWith(renderPost(p));
                } else {
                  container.insertBefore(renderPost(p, 0), container.firstChild);
                }
              });
              posts = Array.from(container.children);
            } catch (err) { console.error('Failed to handle refreshDiff', err); }
          });

          eventSource.onerror = async (err) => {
            console.error('SSE error', err);
            try { eventSource.close(); } catch (e) {}
            eventSource = null;
            // attempt reconnect with backoff
            const wait = backoff + Math.floor(Math.random() * 300);
            backoff = Math.min(maxBackoff, backoff * 2);
            setTimeout(connect, wait);
          };

          // Reset backoff on successful open
          eventSource.onopen = () => { backoff = 1000; };
        } catch (err) {
          console.error('Failed to open SSE (overall)', err);
          try { await auth.currentUser.getIdToken(true); } catch (e) {}
          const wait = backoff + Math.floor(Math.random() * 300);
          backoff = Math.min(maxBackoff, backoff * 2);
          setTimeout(connect, wait);
        }
      };

      connect();
    }

    // Search UI and functions
    function initSearchUI() {
      // Add search bar above posts container
      const container = document.querySelector('.tiktok-feed');
      if (document.getElementById('user-search-bar')) return;
      const searchBar = document.createElement('div');
      searchBar.style.width = '100%';
      searchBar.style.maxWidth = '420px';
      searchBar.style.margin = '12px auto';
      searchBar.style.display = 'flex';
      searchBar.style.gap = '8px';
      searchBar.style.padding = '0 12px';
      searchBar.id = 'user-search-bar';
      searchBar.innerHTML = `
        <input id="user-search-input" placeholder="Search users or friends (username)" style="flex:1;padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.2);color:#fff;" />
        <button id="user-search-btn" style="padding:10px 12px;border-radius:12px;border:none;background:linear-gradient(45deg,#ED64A6,#4C51BF);color:#fff;">Search</button>
      `;
      container.insertBefore(searchBar, container.firstChild);

      const resultsWrap = document.createElement('div');
      resultsWrap.id = 'user-search-results';
      resultsWrap.style.maxWidth = '420px';
      resultsWrap.style.margin = '8px auto';
      resultsWrap.style.padding = '8px 12px';
      container.insertBefore(resultsWrap, container.children[1]);

      document.getElementById('user-search-btn').addEventListener('click', () => {
        const q = document.getElementById('user-search-input').value.trim();
        doUserSearch(q);
      });
      document.getElementById('user-search-input').addEventListener('keyup', (e) => {
        if (e.key === 'Enter') document.getElementById('user-search-btn').click();
      });
    }

    async function doUserSearch(q) {
      const resultsWrap = document.getElementById('user-search-results');
      resultsWrap.innerHTML = '<div style="color:#fff;padding:12px;">Searching...</div>';
      if (!q) { resultsWrap.innerHTML = '<div style="color:#fff;padding:12px;">Enter a username to search.</div>'; return; }
      try {
        if (!window.db) {
          resultsWrap.innerHTML = '<div style="color:#fff;padding:12px;">Search requires Firestore. Backend search will be used if available.</div>';
          // try backend search fallback
          const res = await fetch('/api/users/search?q=' + encodeURIComponent(q));
          if (!res.ok) throw new Error('no-backend');
          const data = await res.json();
          renderUserSearchResults(data || []);
          return;
        }

        // prefix search on username
        const start = q;
        const end = q + '\uf8ff';
        const snap = await window.db.collection('users').orderBy('username').startAt(start).endAt(end).limit(20).get();
        const users = [];
        snap.forEach(doc => {
          const d = doc.data(); d._id = doc.id; users.push(d);
        });
        // if no results, try case-insensitive client filter on small set
        if (!users.length) {
          const snap2 = await window.db.collection('users').limit(50).get();
          snap2.forEach(doc => { const d = doc.data(); d._id = doc.id; if ((d.username||'').toLowerCase().includes(q.toLowerCase())) users.push(d); });
        }
        renderUserSearchResults(users);
      } catch (e) {
        console.error('User search failed', e);
        const resultsWrap = document.getElementById('user-search-results');
        resultsWrap.innerHTML = '<div style="color:#fff;padding:12px;">Search failed. Try again later.</div>';
      }
    }

    function renderUserSearchResults(users) {
      const resultsWrap = document.getElementById('user-search-results');
      resultsWrap.innerHTML = '';
      if (!users || users.length === 0) { resultsWrap.innerHTML = '<div style="color:#fff;padding:12px;">No users found.</div>'; return; }
      users.forEach(u => {
        const card = document.createElement('div');
        card.style.background = 'rgba(255,255,255,0.06)';
        card.style.border = '1px solid rgba(255,255,255,0.08)';
        card.style.padding = '10px';
        card.style.marginBottom = '8px';
        card.style.borderRadius = '12px';
        card.style.color = '#fff';
        const name = document.createElement('div'); name.style.fontWeight = '700'; name.textContent = u.username || u.email || u._id;
        const bio = document.createElement('div'); bio.style.opacity = '0.9'; bio.style.marginTop = '6px'; bio.textContent = u.bio || '';
        const actions = document.createElement('div'); actions.style.marginTop = '8px'; actions.style.display = 'flex'; actions.style.gap = '8px';
        const viewBtn = document.createElement('button'); viewBtn.className = 'back-button'; viewBtn.textContent = 'View Profile'; viewBtn.onclick = () => { window.location.href = 'Profile.html?user=' + encodeURIComponent(u.username || u._id); };
        const friendBtn = document.createElement('button'); friendBtn.className = 'back-button'; friendBtn.style.background = 'linear-gradient(45deg,#48bb78,#2f855a)';
        friendBtn.textContent = 'Add Friend';
        friendBtn.onclick = async () => {
          try {
            const current = auth.currentUser;
            if (!current) return window.location.replace('login.html');
            await follow(current.uid, u.username || u._id);
            friendBtn.textContent = 'Requested'; friendBtn.disabled = true;
          } catch (e) { alert('Failed to add friend'); }
        };
        actions.appendChild(viewBtn); actions.appendChild(friendBtn);
        card.appendChild(name); card.appendChild(bio); card.appendChild(actions);
        resultsWrap.appendChild(card);
      });
    }

    // follow/unfollow helpers (mirror friends.html implementation)
    async function follow(currentUid, profileUsername) {
      if (!window.db) throw new Error('Firestore required');
      await window.db.collection('followers').doc(profileUsername).collection('userFollowers').doc(currentUid).set({ followedAt: firebase.firestore.FieldValue.serverTimestamp() });
      await window.db.collection('following').doc(currentUid).collection('userFollowing').doc(profileUsername).set({ followedAt: firebase.firestore.FieldValue.serverTimestamp() });
    }

    // Cleanup listener when navigating away
    window.addEventListener('beforeunload', () => {
      if (_unsubscribePosts) _unsubscribePosts();
      if (window.postUnsubscribers) {
        Object.values(window.postUnsubscribers).forEach(fn => { try { fn(); } catch (e) {} });
      }
      if (window.postObserver) {
        try { window.postObserver.disconnect(); } catch (e) {}
      }
    });


    if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark-mode');
  </script>
</body>
</html>