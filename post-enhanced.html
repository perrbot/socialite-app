  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Socialite - Create and share amazing posts with your community. üíé‚ú® #SocialiteGlowUp" />
  <meta name="keywords" content="social media, posts, community, sharing, create posts, Socialite, viral content, luxury social network" />
  <meta name="author" content="Socialite Team" />
  <meta name="robots" content="index, follow" />
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://socialite.com/post-enhanced" />
  <meta property="og:title" content="Socialite - Create Post (TikTok-like)" />
  <meta property="og:description" content="Create and share amazing posts with your community. üíé‚ú® #SocialiteGlowUp" />
  <meta property="og:image" content="https://socialite.com/images/post-enhanced.jpg" />
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image" />
  <meta property="twitter:url" content="https://socialite.com/post-enhanced" />
  <meta property="twitter:title" content="Socialite - Create Post (TikTok-like)" />
  <meta property="twitter:description" content="Create and share amazing posts with your community. üíé‚ú® #SocialiteGlowUp" />
  <meta property="twitter:image" content="https://socialite.com/images/post-enhanced.jpg" />
  <title>Socialite - Create Post (TikTok-like)</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" onerror="this.href='';document.body.style.fontFamily='sans-serif';">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <!-- Firebase (compat) for docs: replace placeholders with your project's config -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Poppins', sans-serif;
      height: 100vh;
      width: 100vw;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
    }
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 400px;
      max-height: 100vh;
    }
    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }
    canvas {
      pointer-events: none;
    }
    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .record-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: red;
      border: 4px solid white;
      cursor: pointer;
      transition: all 0.3s;
    }
    .record-btn.recording {
      background: transparent;
      border-color: red;
    }
    .mode-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 20px;
    }
    .music-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 20px;
    }
    .effects-panel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
    }
    .effect-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 16px;
    }
    .text-input {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 10px;
      border: none;
      font-size: 18px;
      text-align: center;
      width: 80%;
      max-width: 300px;
    }
    .save-btn {
      position: absolute;
      top: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 255, 0, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
    }
    .effects-toggle {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 20px;
    }
    .text-toggle {
      position: absolute;
      bottom: 120px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 20px;
    }
    .timer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 18px;
      font-weight: bold;
      display: none;
    }
    .post-btn {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 255, 0, 0.7);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      display: none;
    }
    /* Sign-in Modal */
    .signin-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .signin-modal.active {
      display: flex;
    }
    .signin-modal-content {
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      position: relative;
    }
    .signin-modal-content h2 {
      margin-bottom: 15px;
      color: #333;
      font-size: 24px;
    }
    .signin-modal-content p {
      color: #666;
      margin-bottom: 20px;
      font-size: 14px;
    }
    .signin-modal-content button {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    .signin-btn {
      background: #1f2937;
      color: white;
    }
    .signin-btn:hover {
      background: #111827;
    }
    .demo-btn {
      background: #e5e7eb;
      color: #333;
    }
    .demo-btn:hover {
      background: #d1d5db;
    }
    .close-btn {
      background: transparent;
      color: #999;
      font-size: 20px;
      padding: 0;
      position: absolute;
      top: 10px;
      right: 15px;
      width: auto;
      height: auto;
      border: none;
      cursor: pointer;
    }
    /* Template Guide */
    .template-guide {
      position: absolute;
      bottom: 100px;
      right: 20px;
      width: 120px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 11px;
      display: none;
      z-index: 100;
    }
    .template-guide.show {
      display: block;
    }
    .template-guide h4 {
      margin-bottom: 8px;
      font-weight: 600;
    }
    .template-guide ul {
      list-style: none;
      padding: 0;
    }
    .template-guide li {
      margin: 4px 0;
      opacity: 0.9;
    }
    .auth-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      width: auto;
      height: 40px;
      padding: 0 12px;
      border-radius: 20px;
      background: rgba(255,255,255,0.9);
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: black;
      font-size: 14px;
    }
    #upload-progress {
      display: none;
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 90px;
      z-index: 4000;
      width: 320px;
      max-width: 90%;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 12px;
      color: #fff;
      text-align: center;
      font-family: inherit;
    }
    #upload-progress-text {
      font-size: 13px;
      margin-bottom: 8px;
    }
    .upload-progress-bar-container {
      height: 8px;
      background: rgba(255,255,255,0.12);
      border-radius: 6px;
      overflow: hidden;
    }
    #upload-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg,#ED64A6,#4C51BF);
      transition: width 220ms linear;
    }
    .signin-divider {
      color: #999;
      font-size: 12px;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="auth-btn" class="auth-btn" title="Sign in">Sign in</button>
    <div id="signin-modal" class="signin-modal">
      <div class="signin-modal-content">
        <button class="close-btn" id="close-signin" title="Close">‚úï</button>
        <h2>Sign In to Post</h2>
        <p>Create an authenticated post to share with your account.</p>
        <button class="signin-btn" id="modal-signin-btn">Sign in with Google</button>
        <p class="signin-divider">or</p>
        <button class="demo-btn" id="demo-post-btn">Post as Demo (Public)</button>
      </div>
    </div>
    <div id="template-guide" class="template-guide">
      <h4>üìù Post Tips:</h4>
      <ul>
        <li>‚úì Record 6-60 sec</li>
        <li>‚úì Add engaging text</li>
        <li>‚úì Use effects</li>
        <li>‚úì Share & inspire</li>
      </ul>
    </div>
    <!-- Small upload progress UI -->
    <div id="upload-progress">
      <div id="upload-progress-text">Preparing upload‚Ä¶</div>
      <div class="upload-progress-bar-container">
        <div id="upload-progress-bar"></div>
      </div>
    </div>
    <video id="video" autoplay muted></video>
    <canvas id="canvas"></canvas>
    <button class="save-btn" id="save-btn" aria-label="Save" title="Save"><i class="fas fa-save"></i></button>
    <button class="music-btn" id="music-btn" aria-label="Add Music" title="Add Music"><i class="fas fa-music"></i></button>
    <button class="effects-toggle" id="effects-toggle" aria-label="Effects" title="Effects"><i class="fas fa-magic"></i></button>
    <button class="text-toggle" id="text-toggle" aria-label="Add Text" title="Add Text"><i class="fas fa-font"></i></button>
    <div class="effects-panel" id="effects-panel">
      <button class="effect-btn" data-filter="none">None</button>
      <button class="effect-btn" data-filter="grayscale(100%)">Gray</button>
      <button class="effect-btn" data-filter="sepia(100%)">Sepia</button>
      <button class="effect-btn" data-filter="invert(100%)">Invert</button>
    </div>
    <textarea class="text-input" id="text-input" placeholder="Add text..."></textarea>
    <div class="timer" id="timer">00:00</div>
    <button class="post-btn" id="post-btn" aria-label="Post" title="Post"><i class="fas fa-paper-plane"></i></button>
    <div class="controls">
      <button class="mode-btn" id="mode-btn" aria-label="Switch Mode" title="Switch Mode"><i class="fas fa-camera"></i></button>
      <button class="record-btn" id="record-btn" aria-label="Record Video" title="Record Video"></button>
    </div>
  </div>
  <script>
    // ----- Firebase configuration (fill with your project's values) -----
    const firebaseConfig = {
      apiKey: "REPLACE_WITH_API_KEY",
      authDomain: "REPLACE_WITH_AUTH_DOMAIN",
      projectId: "REPLACE_WITH_PROJECT_ID",
      appId: "REPLACE_WITH_APP_ID"
    };
    if (!window.firebase || !firebase.apps) {
      console.warn('Firebase compat scripts not loaded or incompatible.');
    }
    try {
      if (firebase && !firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
    } catch (e) {
      console.warn('Firebase init error (docs page):', e.message || e);
    }

    // Auth UI elements
    const authBtn = document.getElementById('auth-btn');
    let currentIdToken = null;

    function updateAuthUI(user) {
      if (user) {
        authBtn.textContent = (user.displayName || user.email || 'Signed in') + ' ‚Äî Sign out';
        authBtn.title = 'Sign out';
        // ensure post button visible when signed in
        postBtn.style.display = 'flex';
      } else {
        authBtn.textContent = 'Sign in';
        authBtn.title = 'Sign in';
        postBtn.style.display = 'none';
      }
    }

    // Sign-in with Google popup (docs/demo friendly)
    async function signIn() {
      try {
        const provider = new firebase.auth.GoogleAuthProvider();
        await firebase.auth().signInWithPopup(provider);
      } catch (err) {
        console.error('Sign-in failed:', err);
        alert('Sign-in failed: ' + (err.message || err));
      }
    }

    async function signOut() {
      try {
        await firebase.auth().signOut();
        currentIdToken = null;
      } catch (err) {
        console.error('Sign-out failed:', err);
      }
    }

    // Monitor auth state and refresh ID token when necessary
    if (firebase && firebase.auth) {
      firebase.auth().onAuthStateChanged(async (user) => {
        if (user) {
          try {
            currentIdToken = await user.getIdToken(true);
          } catch (e) {
            console.warn('Failed to get ID token:', e);
            currentIdToken = null;
          }
        } else {
          currentIdToken = null;
        }
        updateAuthUI(user);
      });
    }

    authBtn.addEventListener('click', async () => {
      const user = firebase && firebase.auth && firebase.auth().currentUser;
      if (user) {
        await signOut();
      } else {
        await signIn();
      }
    });

    // Modal handlers
    const signinModal = document.getElementById('signin-modal');
    const templateGuide = document.getElementById('template-guide');

    document.getElementById('close-signin').addEventListener('click', () => {
      signinModal.classList.remove('active');
    });

    document.getElementById('modal-signin-btn').addEventListener('click', async () => {
      await signIn();
      if (firebase && firebase.auth && firebase.auth().currentUser) {
        signinModal.classList.remove('active');
      }
    });

    document.getElementById('demo-post-btn').addEventListener('click', async () => {
      signinModal.classList.remove('active');
      const videoUrl = localStorage.getItem('recordedVideo');
      if (videoUrl) {
        await uploadDemoPost(videoUrl);
      }
    });

    // Upload functions
    async function uploadAuthenticatedPost(videoUrl) {
      const user = firebase && firebase.auth && firebase.auth().currentUser;
      if (!user) {
        alert('Please sign in before posting.');
        return;
      }

      let idToken = null;
      try {
        idToken = await user.getIdToken(true);
      } catch (e) {
        console.error('Failed to get ID token:', e);
        alert('Authentication error. Please sign in again.');
        return;
      }

      const response = await fetch(videoUrl);
      const blob = await response.blob();
      // Attempt resumable chunk upload first (better for large videos)
      try {
        const uploaded = await uploadResumableBlob(blob, currentText || 'New video post');
        if (uploaded && uploaded.filename) {
          // notify server to create post record referencing assembled file
          const fd = new FormData();
          fd.append('mediaFilename', uploaded.filename);
          fd.append('content', currentText || 'New video post');
          const res = await fetch('/api/posts', { method: 'POST', headers: { 'Authorization': 'Bearer ' + idToken }, body: fd });
          if (res.ok) {
            alert('Post created successfully!');
            // emit socket new-post for realtime viewers (best-effort)
            try { if (window.socket) window.socket.emit('newPost', { filename: uploaded.filename, by: (firebase.auth().currentUser && firebase.auth().currentUser.uid) || null }); } catch(_){}
            window.location.href = 'Home.html';
            return;
          } else {
            let body = null; try { body = await res.json(); } catch (e) {}
            console.error('Create post failed', res.status, body);
            alert('Failed to create post: ' + (body && body.error ? body.error : ('Status ' + res.status)));
            return;
          }
        }
      } catch (e) {
        console.warn('Resumable upload failed, falling back to single upload', e);
      }

      // Fallback: single-shot upload
      const formData = new FormData();
      formData.append('media', blob, 'video.webm');
      formData.append('content', currentText || 'New video post');
      try {
        const res = await fetch('/api/posts', {
          method: 'POST',
          headers: { 'Authorization': 'Bearer ' + idToken },
          body: formData
        });
        if (res.ok) {
          alert('Post created successfully!');
          window.location.href = 'Home.html';
        } else {
          let body = null;
          try { body = await res.json(); } catch (e) {}
          console.error('Create post failed', res.status, body);
          alert('Failed to create post: ' + (body && body.error ? body.error : ('Status ' + res.status)));
        }
      } catch (err) {
        console.error('Error posting:', err);
        alert('Error posting video: ' + (err && err.message ? err.message : err));
      }
    }

      // Resumable chunk upload: splits blob into chunks and uploads to /api/uploads/chunk
      async function uploadResumableBlob(blob, text) {
        const CHUNK_SIZE = 1024 * 1024; // 1MB
        const total = Math.ceil(blob.size / CHUNK_SIZE);
        const uploadId = 'upl-' + Date.now() + '-' + Math.random().toString(36).slice(2,8);
        const user = firebase && firebase.auth && firebase.auth().currentUser;
        if (!user) throw new Error('not-authenticated');
        const idToken = await user.getIdToken(true);
        // progress UI elements
        const progressEl = document.getElementById('upload-progress');
        const progressBar = document.getElementById('upload-progress-bar');
        const progressText = document.getElementById('upload-progress-text');
        if (progressEl && progressBar && progressText) {
          progressEl.style.display = 'block';
          progressBar.style.width = '0%';
          progressText.textContent = `Uploading 0% (0/${total})`;
        }
        for (let i = 0; i < total; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(blob.size, start + CHUNK_SIZE);
          const part = blob.slice(start, end);
          const fd = new FormData();
          fd.append('chunk', part, 'chunk');
          fd.append('uploadId', uploadId);
          fd.append('index', String(i));
          fd.append('total', String(total));
          fd.append('filename', 'video.webm');
          try {
            const res = await fetch('/api/uploads/chunk', { method: 'POST', headers: { 'Authorization': 'Bearer ' + idToken }, body: fd });
            if (!res.ok) { const b = await res.text().catch(()=>null); throw new Error('chunk upload failed: ' + (b || res.status)); }
            const json = await res.json().catch(()=>null);
            // if server replies with final assembled file info, return it
            if (json && json.path) return { filename: json.filename || json.path };
            // update progress UI
            try {
              if (progressBar && progressText) {
                const pct = Math.round(((i + 1) / total) * 100);
                progressBar.style.width = pct + '%';
                progressText.textContent = `Uploading ${pct}% (${i+1}/${total})`;
              }
            } catch (e) { /* ignore UI errors */ }
          } catch (e) {
            console.error('Chunk upload error', e);
            if (progressText) progressText.textContent = 'Upload failed';
            // hide progress after short delay
            setTimeout(() => { try { progressEl.style.display='none'; } catch(_){} }, 1400);
            throw e;
          }
        }
        // If server didn't return assembled file, try to ask backend for assembled filename
        try {
          const info = await fetch('/api/uploads/info?uploadId=' + encodeURIComponent(uploadId), { headers: { 'Authorization': 'Bearer ' + idToken } });
          if (info.ok) return await info.json();
        } catch (_) {}
        if (progressText) progressText.textContent = 'Finalizing...';
        // hide progress UI after a short delay
        setTimeout(() => { try { const el = document.getElementById('upload-progress'); if (el) el.style.display='none'; } catch(_){} }, 800);
        return null;
      }

    async function uploadDemoPost(videoUrl) {
      const response = await fetch(videoUrl);
      const blob = await response.blob();
      const formData = new FormData();
      formData.append('media', blob, 'video.webm');
      formData.append('content', currentText || 'New video post');

      try {
        const res = await fetch('/api/posts/public', {
          method: 'POST',
          body: formData
        });
        if (res.ok) {
          alert('Demo post created successfully!');
          window.location.href = 'Home.html';
        } else {
          let body = null;
          try { body = await res.json(); } catch (e) {}
          console.error('Create demo post failed', res.status, body);
          alert('Failed to create post: ' + (body && body.error ? body.error : ('Status ' + res.status)));
        }
      } catch (err) {
        console.error('Error posting (demo):', err);
        alert('Error posting demo video: ' + (err && err.message ? err.message : err));
      }
    }

    // Update auth UI to show template when signed in
    function updateAuthUI(user) {
      if (user) {
        authBtn.textContent = (user.displayName || user.email || 'Signed in') + ' ‚Äî Sign out';
        postBtn.style.display = 'flex';
        templateGuide.classList.add('show');
      } else {
        authBtn.textContent = 'Sign in';
        postBtn.style.display = 'none';
        templateGuide.classList.remove('show');
      }
    }

    // Re-register auth state listener to use updated updateAuthUI
    if (firebase && firebase.auth) {
      firebase.auth().onAuthStateChanged(async (user) => {
        if (user) {
          try {
            currentIdToken = await user.getIdToken(true);
          } catch (e) {
            console.warn('Failed to get ID token:', e);
            currentIdToken = null;
          }
        } else {
          currentIdToken = null;
        }
        updateAuthUI(user);
      });
    }

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const recordBtn = document.getElementById('record-btn');
    const modeBtn = document.getElementById('mode-btn');
    const musicBtn = document.getElementById('music-btn');
    const saveBtn = document.getElementById('save-btn');
    const effectsToggle = document.getElementById('effects-toggle');
    const textToggle = document.getElementById('text-toggle');
    const effectsPanel = document.getElementById('effects-panel');
    const textInput = document.getElementById('text-input');
    const effectBtns = document.querySelectorAll('.effect-btn');
    const timer = document.getElementById('timer');
    const postBtn = document.getElementById('post-btn');

    let stream;
    let recorder;
    let recordedChunks = [];
    let isRecording = false;
    let currentFilter = 'none';
    let currentText = '';
    let timerInterval;
    let startTime;

    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Get user media
    async function startCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        video.srcObject = stream;
      } catch (err) {
        console.error('Error accessing camera:', err);
      }
    }

    // Start recording
    function startRecording() {
      recordedChunks = [];
      recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      recorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };
      recorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        // Save to localStorage or download
        localStorage.setItem('recordedVideo', url);
        // Persist draft to IndexedDB for offline sync
        (async function saveDraftBlob() {
          try {
            await saveDraft({ id: 'draft-' + Date.now(), blob, text: currentText || '' });
            console.log('Draft saved to IndexedDB');
          } catch (e) { console.warn('failed to save draft', e); }
        })();
        // Hide timer and show post button
        timer.style.display = 'none';
        postBtn.style.display = 'flex';
        clearInterval(timerInterval);
      };
      recorder.start();
      isRecording = true;
      recordBtn.classList.add('recording');
      // Start timer
      startTime = Date.now();
      timer.style.display = 'block';
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timer.textContent = `${minutes}:${seconds}`;
      }, 1000);
    }

    // Stop recording
    function stopRecording() {
      recorder.stop();
      isRecording = false;
      recordBtn.classList.remove('recording');
    }

    // Draw canvas
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.filter = currentFilter;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.filter = 'none';
      if (currentText) {
        ctx.font = '30px Poppins';
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.fillText(currentText, canvas.width / 2, canvas.height / 2);
      }
      requestAnimationFrame(draw);
    }

    // Event listeners
    recordBtn.addEventListener('click', () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    modeBtn.addEventListener('click', () => {
      // Toggle between camera and text mode (simplified)
      alert('Mode switched!');
    });

    musicBtn.addEventListener('click', () => {
      // Add music/sound integration (placeholder)
      alert('Music added!');
    });

    saveBtn.addEventListener('click', () => {
      // Save canvas as image
      const dataURL = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = dataURL;
      link.download = 'post-image.png';
      link.click();
    });

    effectsToggle.addEventListener('click', () => {
      effectsPanel.style.display = effectsPanel.style.display === 'flex' ? 'none' : 'flex';
    });

    textToggle.addEventListener('click', () => {
      textInput.style.display = textInput.style.display === 'block' ? 'none' : 'block';
      if (textInput.style.display === 'block') {
        textInput.focus();
      }
    });

    textInput.addEventListener('input', (e) => {
      currentText = e.target.value;
    });

    effectBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        currentFilter = btn.dataset.filter;
      });
    });

    postBtn.addEventListener('click', async () => {
      const videoUrl = localStorage.getItem('recordedVideo');
      if (!videoUrl) {
        alert('No video recorded!');
        return;
      }

      const user = firebase && firebase.auth && firebase.auth().currentUser;
      if (!user) {
        signinModal.classList.add('active');
        return;
      }

      await uploadAuthenticatedPost(videoUrl);
    });

    // --- Offline draft storage & sync (IndexedDB) ---
    function openDB() {
      return new Promise((resolve, reject) => {
        const rq = indexedDB.open('socialite-drafts-v1', 1);
        rq.onupgradeneeded = () => {
          rq.result.createObjectStore('drafts', { keyPath: 'id' });
        };
        rq.onsuccess = () => resolve(rq.result);
        rq.onerror = () => reject(rq.error);
      });
    }

    async function saveDraft(draft) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('drafts', 'readwrite');
        const store = tx.objectStore('drafts');
        store.put(draft);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function listDrafts() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('drafts', 'readonly');
        const store = tx.objectStore('drafts');
        const rq = store.getAll();
        rq.onsuccess = () => resolve(rq.result || []);
        rq.onerror = () => reject(rq.error);
      });
    }

    async function deleteDraft(id) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction('drafts', 'readwrite');
        tx.objectStore('drafts').delete(id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function uploadAuthenticatedBlob(blob, text) {
      const user = firebase && firebase.auth && firebase.auth().currentUser;
      if (!user) { console.warn('no user for upload'); return false; }
      const idToken = await user.getIdToken(true);
      const formData = new FormData();
      formData.append('media', blob, 'video.webm');
      formData.append('content', text || 'Draft upload');
      const res = await fetch('/api/posts', { method: 'POST', headers: { 'Authorization':'Bearer ' + idToken }, body: formData });
      return res.ok;
    }

    async function syncDrafts() {
      try {
        const drafts = await listDrafts();
        for (const d of drafts) {
          try {
            const ok = await uploadAuthenticatedBlob(d.blob, d.text);
            if (ok) {
              await deleteDraft(d.id);
              console.log('Draft synced and removed', d.id);
            }
          } catch (e) { console.warn('sync draft failed', e); }
        }
      } catch (e) { console.warn('syncDrafts failed', e); }
    }

    window.addEventListener('online', () => {
      console.log('Online - attempting to sync drafts');
      syncDrafts();
    });

    // Allow manual draft save using Save button
    saveBtn.addEventListener('click', async () => {
      try {
        const videoUrl = localStorage.getItem('recordedVideo');
        if (!videoUrl) return alert('No video to save');
        // Fetch blob and save
        const r = await fetch(videoUrl);
        const blob = await r.blob();
        await saveDraft({ id: 'draft-' + Date.now(), blob, text: currentText || '' });
        alert('Draft saved for offline sync');
      } catch (e) { console.error('save draft failed', e); alert('Failed to save draft'); }
    });

    // Initialize
    startCamera();
    draw();
  </script>
</body>
</html>
